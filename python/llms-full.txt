# LLMs Full Documentation - Python Ecosystem
# Systentando Backend Monorepo

## Visão Geral do Domínio Python

O ecossistema Python no Systentando é responsável por inteligência artificial, onboarding personalizado, e sistemas de nutrição. Utiliza FastAPI como framework principal, PostgreSQL como banco de dados, e implementa o Agno Framework para agentes de IA com memória persistente.

## Stack Tecnológica

### Framework e Linguagem
- **Python**: 3.11+ (Linguagem principal)
- **FastAPI**: 0.104+ (Framework web)
- **Pydantic**: 2.x+ (Validação de dados)
- **Uvicorn**: (Servidor ASGI)

### Banco de Dados
- **PostgreSQL**: 15+ (Banco principal)
- **SQLAlchemy**: 2.x+ (ORM)
- **Alembic**: (Migrações)
- **Redis**: 7.x+ (Cache e sessões)

### Inteligência Artificial
- **Agno Framework**: (Framework de agentes IA)
- **OpenAI**: (GPT-4, Embeddings)
- **Tavily**: (Pesquisa web inteligente)
- **LangChain**: (Orquestração de LLMs)
- **ChromaDB**: (Vector database)

### Autenticação e Segurança
- **JWT**: PyJWT (Tokens)
- **bcrypt**: (Hash de senhas)
- **python-multipart**: (Upload de arquivos)
- **python-jose**: (Criptografia)

### Testes e Qualidade
- **pytest**: (Framework de testes)
- **pytest-asyncio**: (Testes assíncronos)
- **black**: (Formatação de código)
- **isort**: (Organização de imports)
- **flake8**: (Linting)

## Estrutura de Diretórios

```
python/
├── life-tracker/
│   └── agent-onboarding/           # Agente IA com Agno Framework
│       ├── core/                   # Core do agente
│       │   ├── __init__.py
│       │   ├── agent.py            # Classe principal do agente
│       │   ├── memory.py           # Gerenciamento de memória
│       │   ├── tools.py             # Ferramentas do agente
│       │   └── config.py            # Configurações
│       ├── tools/                   # Ferramentas especializadas
│       │   ├── __init__.py
│       │   ├── profile_analyzer.py  # Análise de perfil
│       │   ├── goal_setter.py       # Definição de metas
│       │   ├── habit_tracker.py     # Tracking de hábitos
│       │   ├── nutrition_advisor.py # Conselhos nutricionais
│       │   ├── productivity_boost.py # Boost de produtividade
│       │   ├── business_mentor.py    # Mentoria de negócios
│       │   └── investment_guide.py   # Guia de investimentos
│       ├── memory/                  # Memória persistente
│       │   ├── __init__.py
│       │   ├── database.py          # Conexão PostgreSQL
│       │   ├── models.py            # Modelos SQLAlchemy
│       │   ├── repositories.py      # Repositórios
│       │   └── schemas.py           # Schemas Pydantic
│       ├── api/                     # Endpoints FastAPI
│       │   ├── __init__.py
│       │   ├── main.py              # Aplicação principal
│       │   ├── routes/              # Rotas da API
│       │   │   ├── __init__.py
│       │   │   ├── onboarding.py    # Rotas de onboarding
│       │   │   ├── memory.py        # Rotas de memória
│       │   │   └── tools.py         # Rotas de ferramentas
│       │   ├── middleware/          # Middleware customizado
│       │   │   ├── __init__.py
│       │   │   ├── auth.py          # Autenticação
│       │   │   ├── cors.py          # CORS
│       │   │   └── logging.py       # Logging
│       │   └── dependencies.py      # Dependências
│       ├── tests/                   # Testes
│       │   ├── __init__.py
│       │   ├── test_agent.py
│       │   ├── test_tools.py
│       │   ├── test_memory.py
│       │   └── test_api.py
│       ├── requirements.txt         # Dependências
│       ├── alembic.ini             # Configuração Alembic
│       └── README.md
├── meu-nutri/                      # Sistema de Nutrição
│   ├── src/
│   │   ├── __init__.py
│   │   ├── main.py                  # Aplicação FastAPI
│   │   ├── models/                  # Modelos de dados
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── meal.py
│   │   │   ├── nutrition.py
│   │   │   └── recommendation.py
│   │   ├── services/               # Serviços de negócio
│   │   │   ├── __init__.py
│   │   │   ├── nutrition_service.py
│   │   │   ├── ai_service.py
│   │   │   └── recommendation_service.py
│   │   ├── api/                    # Endpoints da API
│   │   │   ├── __init__.py
│   │   │   ├── nutrition.py
│   │   │   ├── meals.py
│   │   │   └── recommendations.py
│   │   ├── core/                   # Configurações
│   │   │   ├── __init__.py
│   │   │   ├── config.py
│   │   │   ├── database.py
│   │   │   └── security.py
│   │   └── utils/                  # Utilitários
│   │       ├── __init__.py
│   │       ├── nutrition_calculator.py
│   │       └── image_processor.py
│   ├── tests/
│   ├── requirements.txt
│   └── README.md
└── examples-agno/                   # Exemplos do Agno Framework
    ├── basic_agent.py
    ├── memory_agent.py
    ├── tool_agent.py
    └── multi_agent.py
```

## Agno Framework - Agente de Onboarding

### Visão Geral
O Agno Framework é um sistema de agentes de IA personalizados que utiliza memória persistente para criar experiências de onboarding únicas e adaptáveis para cada usuário.

### Core do Agente
```python
from agno import Agent, Memory, Tool
from typing import Dict, List, Any
import asyncio

class OnboardingAgent:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.agent = Agent(
            name="Systentando Onboarding Assistant",
            description="Personalized onboarding agent for developers",
            memory=Memory(user_id=user_id),
            tools=self._initialize_tools()
        )
    
    def _initialize_tools(self) -> List[Tool]:
        return [
            ProfileAnalyzer(),
            GoalSetter(),
            HabitTracker(),
            NutritionAdvisor(),
            ProductivityBoost(),
            BusinessMentor(),
            InvestmentGuide()
        ]
    
    async def process_user_input(self, message: str) -> str:
        """Processa entrada do usuário e retorna resposta personalizada"""
        context = await self.agent.memory.get_context()
        response = await self.agent.process(message, context)
        await self.agent.memory.store_interaction(message, response)
        return response
```

### Ferramentas Especializadas

#### 1. Profile Analyzer
```python
class ProfileAnalyzer(Tool):
    def __init__(self):
        super().__init__(
            name="profile_analyzer",
            description="Analyzes user profile and preferences"
        )
    
    async def execute(self, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analisa perfil do usuário e retorna insights"""
        analysis = {
            "personality_type": self._analyze_personality(user_data),
            "learning_style": self._identify_learning_style(user_data),
            "goals_alignment": self._check_goals_alignment(user_data),
            "recommendations": self._generate_recommendations(user_data)
        }
        return analysis
    
    def _analyze_personality(self, data: Dict) -> str:
        # Implementação da análise de personalidade
        pass
    
    def _identify_learning_style(self, data: Dict) -> str:
        # Identificação do estilo de aprendizado
        pass
```

#### 2. Goal Setter
```python
class GoalSetter(Tool):
    def __init__(self):
        super().__init__(
            name="goal_setter",
            description="Helps users set and track goals"
        )
    
    async def execute(self, goal_data: Dict[str, Any]) -> Dict[str, Any]:
        """Define e acompanha metas do usuário"""
        goal = {
            "id": str(uuid.uuid4()),
            "title": goal_data["title"],
            "description": goal_data["description"],
            "category": goal_data["category"],
            "priority": goal_data["priority"],
            "deadline": goal_data["deadline"],
            "milestones": self._create_milestones(goal_data),
            "created_at": datetime.utcnow()
        }
        return goal
```

#### 3. Habit Tracker
```python
class HabitTracker(Tool):
    def __init__(self):
        super().__init__(
            name="habit_tracker",
            description="Tracks and analyzes user habits"
        )
    
    async def execute(self, habit_data: Dict[str, Any]) -> Dict[str, Any]:
        """Rastreia e analisa hábitos do usuário"""
        habit = {
            "id": str(uuid.uuid4()),
            "name": habit_data["name"],
            "frequency": habit_data["frequency"],
            "target": habit_data["target"],
            "current_streak": 0,
            "best_streak": 0,
            "completion_rate": 0.0
        }
        return habit
```

### Sistema de Memória Persistente

#### Modelos de Banco de Dados
```python
from sqlalchemy import Column, Integer, String, DateTime, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.postgresql import UUID
import uuid

Base = declarative_base()

class UserMemory(Base):
    __tablename__ = "user_memories"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String, nullable=False, index=True)
    interaction_type = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    metadata = Column(JSON)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
class UserProfile(Base):
    __tablename__ = "user_profiles"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String, nullable=False, unique=True, index=True)
    personality_type = Column(String)
    learning_style = Column(String)
    goals = Column(JSON)
    preferences = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

#### Repositório de Memória
```python
class MemoryRepository:
    def __init__(self, db_session):
        self.db = db_session
    
    async def store_interaction(self, user_id: str, interaction: Dict[str, Any]):
        """Armazena interação do usuário"""
        memory = UserMemory(
            user_id=user_id,
            interaction_type=interaction["type"],
            content=interaction["content"],
            metadata=interaction.get("metadata", {})
        )
        self.db.add(memory)
        await self.db.commit()
    
    async def get_user_context(self, user_id: str, limit: int = 10) -> List[Dict]:
        """Recupera contexto do usuário"""
        memories = await self.db.query(UserMemory)\
            .filter(UserMemory.user_id == user_id)\
            .order_by(UserMemory.timestamp.desc())\
            .limit(limit)\
            .all()
        
        return [{
            "type": m.interaction_type,
            "content": m.content,
            "timestamp": m.timestamp,
            "metadata": m.metadata
        } for m in memories]
```

## Sistema de Nutrição - Meu Nutri

### Visão Geral
O Meu Nutri é um sistema de assistência nutricional com IA que analisa refeições, oferece recomendações personalizadas e acompanha o progresso nutricional do usuário.

### Modelos de Dados
```python
from sqlalchemy import Column, Integer, String, Float, DateTime, Text, JSON
from sqlalchemy.dialects.postgresql import UUID
import uuid

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, nullable=False)
    name = Column(String, nullable=False)
    age = Column(Integer)
    weight = Column(Float)
    height = Column(Float)
    activity_level = Column(String)
    dietary_restrictions = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class Meal(Base):
    __tablename__ = "meals"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID, ForeignKey("users.id"), nullable=False)
    name = Column(String, nullable=False)
    description = Column(Text)
    image_url = Column(String)
    meal_type = Column(String)  # breakfast, lunch, dinner, snack
    timestamp = Column(DateTime, default=datetime.utcnow)
    nutrition_data = Column(JSON)

class NutritionAnalysis(Base):
    __tablename__ = "nutrition_analyses"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    meal_id = Column(UUID, ForeignKey("meals.id"), nullable=False)
    calories = Column(Float)
    protein = Column(Float)
    carbs = Column(Float)
    fat = Column(Float)
    fiber = Column(Float)
    sugar = Column(Float)
    sodium = Column(Float)
    ai_analysis = Column(Text)
    recommendations = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
```

### Serviços de Negócio

#### Nutrition Service
```python
class NutritionService:
    def __init__(self, ai_service: AIService, db_session):
        self.ai_service = ai_service
        self.db = db_session
    
    async def analyze_meal(self, meal_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analisa refeição usando IA"""
        # Processamento de imagem (se fornecida)
        if meal_data.get("image_url"):
            image_analysis = await self.ai_service.analyze_food_image(
                meal_data["image_url"]
            )
            meal_data.update(image_analysis)
        
        # Análise nutricional com IA
        nutrition_analysis = await self.ai_service.analyze_nutrition(
            meal_data["description"],
            meal_data.get("ingredients", [])
        )
        
        # Geração de recomendações
        recommendations = await self.ai_service.generate_recommendations(
            nutrition_analysis,
            meal_data["user_id"]
        )
        
        return {
            "nutrition_data": nutrition_analysis,
            "recommendations": recommendations,
            "health_score": self._calculate_health_score(nutrition_analysis)
        }
    
    def _calculate_health_score(self, nutrition: Dict) -> float:
        """Calcula score de saúde da refeição"""
        # Implementação do cálculo de score
        pass
```

#### AI Service
```python
class AIService:
    def __init__(self, openai_client, tavily_client):
        self.openai = openai_client
        self.tavily = tavily_client
    
    async def analyze_food_image(self, image_url: str) -> Dict[str, Any]:
        """Analisa imagem de comida usando GPT-4 Vision"""
        response = await self.openai.chat.completions.create(
            model="gpt-4-vision-preview",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": "Analyze this food image and identify the ingredients, estimate portions, and provide nutritional information."},
                        {"type": "image_url", "image_url": {"url": image_url}}
                    ]
                }
            ],
            max_tokens=1000
        )
        
        return self._parse_food_analysis(response.choices[0].message.content)
    
    async def analyze_nutrition(self, description: str, ingredients: List[str]) -> Dict[str, Any]:
        """Analisa informações nutricionais"""
        prompt = f"""
        Analyze the following meal description and ingredients for nutritional content:
        
        Description: {description}
        Ingredients: {', '.join(ingredients)}
        
        Provide:
        1. Estimated calories
        2. Macronutrients (protein, carbs, fat)
        3. Micronutrients (vitamins, minerals)
        4. Health assessment
        5. Potential improvements
        """
        
        response = await self.openai.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=800
        )
        
        return self._parse_nutrition_analysis(response.choices[0].message.content)
```

### Endpoints da API

#### Nutrition Routes
```python
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from typing import List, Optional

router = APIRouter(prefix="/api/nutrition", tags=["nutrition"])

@router.post("/analyze-meal")
async def analyze_meal(
    meal_data: MealAnalysisRequest,
    current_user: User = Depends(get_current_user),
    nutrition_service: NutritionService = Depends(get_nutrition_service)
):
    """Analisa refeição e retorna informações nutricionais"""
    try:
        analysis = await nutrition_service.analyze_meal(meal_data.dict())
        return {
            "success": True,
            "data": analysis,
            "timestamp": datetime.utcnow()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/upload-image")
async def upload_meal_image(
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    nutrition_service: NutritionService = Depends(get_nutrition_service)
):
    """Upload de imagem de refeição para análise"""
    try:
        # Processar upload da imagem
        image_url = await nutrition_service.upload_image(file)
        
        # Analisar imagem
        analysis = await nutrition_service.analyze_food_image(image_url)
        
        return {
            "success": True,
            "image_url": image_url,
            "analysis": analysis
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/recommendations/{user_id}")
async def get_nutrition_recommendations(
    user_id: str,
    current_user: User = Depends(get_current_user),
    nutrition_service: NutritionService = Depends(get_nutrition_service)
):
    """Obtém recomendações nutricionais personalizadas"""
    try:
        recommendations = await nutrition_service.get_recommendations(user_id)
        return {
            "success": True,
            "recommendations": recommendations
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

## Configuração e Deploy

### Environment Variables
```bash
# Database
DATABASE_URL=postgresql://user:pass@localhost:5432/systentando
REDIS_URL=redis://localhost:6379

# AI Services
OPENAI_API_KEY=your-openai-api-key
TAVILY_API_KEY=your-tavily-api-key

# Authentication
JWT_SECRET=your-jwt-secret
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=15

# Application
PYTHONPATH=/app
ENVIRONMENT=development
DEBUG=True
LOG_LEVEL=INFO
```

### Docker Configuration
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Expose port
EXPOSE 8000

# Run application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Requirements
```txt
# Core Framework
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
pydantic-settings==2.1.0

# Database
sqlalchemy==2.0.23
alembic==1.13.1
psycopg2-binary==2.9.9
redis==5.0.1

# AI and ML
openai==1.3.7
tavily-python==0.3.0
langchain==0.0.350
chromadb==0.4.18

# Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6

# HTTP Client
httpx==0.25.2
aiohttp==3.9.1

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0

# Code Quality
black==23.11.0
isort==5.12.0
flake8==6.1.0
mypy==1.7.1

# Monitoring
structlog==23.2.0
prometheus-client==0.19.0
```

## Testes

### Unit Tests
```python
import pytest
from unittest.mock import Mock, AsyncMock
from services.nutrition_service import NutritionService
from services.ai_service import AIService

@pytest.fixture
def mock_ai_service():
    return Mock(spec=AIService)

@pytest.fixture
def nutrition_service(mock_ai_service, mock_db):
    return NutritionService(mock_ai_service, mock_db)

@pytest.mark.asyncio
async def test_analyze_meal(nutrition_service, mock_ai_service):
    # Arrange
    meal_data = {
        "description": "Grilled chicken with rice",
        "ingredients": ["chicken", "rice", "vegetables"]
    }
    
    mock_ai_service.analyze_nutrition.return_value = {
        "calories": 400,
        "protein": 30,
        "carbs": 45,
        "fat": 12
    }
    
    # Act
    result = await nutrition_service.analyze_meal(meal_data)
    
    # Assert
    assert result["nutrition_data"]["calories"] == 400
    assert result["nutrition_data"]["protein"] == 30
    mock_ai_service.analyze_nutrition.assert_called_once()
```

### Integration Tests
```python
import pytest
from httpx import AsyncClient
from main import app

@pytest.mark.asyncio
async def test_analyze_meal_endpoint():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/nutrition/analyze-meal",
            json={
                "description": "Grilled chicken with rice",
                "ingredients": ["chicken", "rice", "vegetables"]
            },
            headers={"Authorization": "Bearer test-token"}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert "nutrition_data" in data["data"]
```

## Monitoramento e Logs

### Structured Logging
```python
import structlog
from structlog import get_logger

logger = get_logger()

class NutritionService:
    async def analyze_meal(self, meal_data: Dict[str, Any]) -> Dict[str, Any]:
        logger.info(
            "Analyzing meal",
            user_id=meal_data.get("user_id"),
            meal_type=meal_data.get("meal_type"),
            has_image=bool(meal_data.get("image_url"))
        )
        
        try:
            analysis = await self._perform_analysis(meal_data)
            logger.info(
                "Meal analysis completed",
                user_id=meal_data.get("user_id"),
                calories=analysis.get("calories"),
                health_score=analysis.get("health_score")
            )
            return analysis
        except Exception as e:
            logger.error(
                "Meal analysis failed",
                user_id=meal_data.get("user_id"),
                error=str(e),
                exc_info=True
            )
            raise
```

### Health Checks
```python
from fastapi import APIRouter, Depends
from sqlalchemy import text

router = APIRouter()

@router.get("/health")
async def health_check(db_session=Depends(get_db_session)):
    """Health check endpoint"""
    try:
        # Test database connection
        await db_session.execute(text("SELECT 1"))
        
        # Test Redis connection
        redis_client = get_redis_client()
        await redis_client.ping()
        
        return {
            "status": "healthy",
            "timestamp": datetime.utcnow().isoformat(),
            "services": {
                "database": "up",
                "redis": "up"
            }
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }
```

## Próximos Passos

### Fase 1: Consolidação
- [ ] Implementação completa do Agno Framework
- [ ] Integração com OpenAI e Tavily
- [ ] Sistema de memória persistente
- [ ] Testes automatizados (cobertura 80%+)

### Fase 2: Otimização
- [ ] Cache inteligente com Redis
- [ ] Otimização de queries PostgreSQL
- [ ] Rate limiting e throttling
- [ ] Monitoramento avançado

### Fase 3: Escala
- [ ] Microserviços independentes
- [ ] Load balancing
- [ ] Auto-scaling
- [ ] Disaster recovery

## Recursos Adicionais

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- [OpenAI API Documentation](https://platform.openai.com/docs)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
